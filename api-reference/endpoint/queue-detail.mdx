---
title: 'æŸ¥è¯¢é˜Ÿåˆ—è¯¦æƒ…'
openapi: 'GET /v2/quecrule/r1/openapi/queue/detail'
---

## é˜Ÿåˆ—è¯¦æƒ…æŸ¥è¯¢

è·å–æŒ‡å®šæ¶ˆæ¯é˜Ÿåˆ—çš„è¯¦ç»†ä¿¡æ¯ï¼ŒåŒ…æ‹¬é˜Ÿåˆ—çŠ¶æ€ã€æ¶ˆæ¯ç»Ÿè®¡ã€è¿æ¥é…ç½®å’Œç®¡ç†ä¿¡æ¯ã€‚è¿™ä¸ªæ¥å£æä¾›äº†é˜Ÿåˆ—ç®¡ç†å’Œç›‘æ§æ‰€éœ€çš„å…¨é¢æ•°æ®ã€‚

## è¿”å›ä¿¡æ¯

<CardGroup cols={2}>
  <Card title="åŸºæœ¬ä¿¡æ¯" icon="info-circle">
    é˜Ÿåˆ—åç§°ã€IDã€æè¿°å’Œåˆ›å»ºæ—¶é—´
  </Card>
  <Card title="æ¶ˆæ¯ç»Ÿè®¡" icon="chart-bar">
    æ¶ˆæ¯æ•°é‡ã€æ¶ˆè´¹é€Ÿç‡å’Œå †ç§¯å¤§å°
  </Card>
  <Card title="è¿æ¥é…ç½®" icon="plug">
    AMQPè¿æ¥åœ°å€å’Œè®¿é—®å‚æ•°
  </Card>
  <Card title="è¿è¡ŒçŠ¶æ€" icon="heartbeat">
    é˜Ÿåˆ—çŠ¶æ€ã€æ›´æ–°æ—¶é—´å’Œå¥åº·åº¦
  </Card>
</CardGroup>

## ä½¿ç”¨åœºæ™¯

<CardGroup cols={3}>
  <Card title="ç›‘æ§å‘Šè­¦" icon="bell">
    ç›‘æ§é˜Ÿåˆ—æ¶ˆæ¯ç§¯å‹å’Œå¤„ç†æ€§èƒ½
  </Card>
  <Card title="æ•…éšœæ’æŸ¥" icon="wrench">
    è¯Šæ–­é˜Ÿåˆ—å¼‚å¸¸å’Œè¿æ¥é—®é¢˜
  </Card>
  <Card title="å®¹é‡è§„åˆ’" icon="chart-line">
    åˆ†æé˜Ÿåˆ—ä½¿ç”¨æƒ…å†µåˆ¶å®šæ‰©å®¹è®¡åˆ’
  </Card>
</CardGroup>

## ä»£ç ç¤ºä¾‹

<CodeGroup>

```javascript JavaScript
async function getQueueDetail(token, queueId) {
  const response = await fetch(
    `https://iot-api.quectelcn.com/v2/quecrule/r1/openapi/queue/detail?queueId=${queueId}`,
    {
      method: 'GET',
      headers: {
        'Authorization': token,
        'Content-Type': 'application/x-www-form-urlencoded'
      }
    }
  );
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  
  return await response.json();
}

// åŸºæœ¬æŸ¥è¯¢æ“ä½œ
try {
  const detail = await getQueueDetail(token, 12345);
  console.log('é˜Ÿåˆ—è¯¦æƒ…:', detail.data);
} catch (error) {
  console.error('è·å–é˜Ÿåˆ—è¯¦æƒ…å¤±è´¥:', error.message);
}

// é˜Ÿåˆ—çŠ¶æ€æ£€æŸ¥å™¨
async function checkQueueHealth(token, queueId) {
  try {
    const detail = await getQueueDetail(token, queueId);
    const queueData = detail.data;
    
    const healthStatus = {
      queueId: queueId,
      queueName: queueData.queueName,
      isHealthy: true,
      issues: [],
      recommendations: []
    };
    
    // æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
    if (queueData.status !== 0) {
      healthStatus.isHealthy = false;
      healthStatus.issues.push(`é˜Ÿåˆ—çŠ¶æ€å¼‚å¸¸: ${queueData.status}`);
    }
    
    // æ£€æŸ¥æ¶ˆæ¯ç§¯å‹
    if (queueData.msgNum > 10000) {
      healthStatus.isHealthy = false;
      healthStatus.issues.push(`æ¶ˆæ¯ç§¯å‹è¿‡å¤š: ${queueData.msgNum}`);
      healthStatus.recommendations.push('è€ƒè™‘å¢åŠ æ¶ˆè´¹è€…æ•°é‡æˆ–ä¼˜åŒ–æ¶ˆæ¯å¤„ç†é€»è¾‘');
    }
    
    // æ£€æŸ¥æ¶ˆè´¹é€Ÿç‡
    const consumeRate = parseFloat(queueData.consumeRate);
    if (consumeRate === 0 && queueData.msgNum > 0) {
      healthStatus.isHealthy = false;
      healthStatus.issues.push('æ¶ˆè´¹é€Ÿç‡ä¸º0ä½†å­˜åœ¨æ¶ˆæ¯ç§¯å‹');
      healthStatus.recommendations.push('æ£€æŸ¥æ¶ˆè´¹è€…è¿æ¥çŠ¶æ€');
    }
    
    // æ£€æŸ¥è¿æ¥åœ°å€
    if (!queueData.connectUrl) {
      healthStatus.issues.push('ç¼ºå°‘è¿æ¥åœ°å€é…ç½®');
    }
    
    return healthStatus;
    
  } catch (error) {
    return {
      queueId: queueId,
      isHealthy: false,
      issues: [`è·å–é˜Ÿåˆ—è¯¦æƒ…å¤±è´¥: ${error.message}`],
      recommendations: ['æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œè®¤è¯ä¿¡æ¯']
    };
  }
}

// æ‰¹é‡æ£€æŸ¥å¤šä¸ªé˜Ÿåˆ—
async function checkMultipleQueues(token, queueIds) {
  const results = [];
  
  for (const queueId of queueIds) {
    const health = await checkQueueHealth(token, queueId);
    results.push(health);
    
    // è¾“å‡ºå¥åº·çŠ¶æ€
    if (health.isHealthy) {
      console.log(`âœ“ é˜Ÿåˆ— ${queueId} (${health.queueName}) çŠ¶æ€æ­£å¸¸`);
    } else {
      console.log(`âœ— é˜Ÿåˆ— ${queueId} (${health.queueName}) å­˜åœ¨é—®é¢˜:`);
      health.issues.forEach(issue => console.log(`  - ${issue}`));
      if (health.recommendations.length > 0) {
        console.log('  å»ºè®®:');
        health.recommendations.forEach(rec => console.log(`  - ${rec}`));
      }
    }
  }
  
  return results;
}

// é˜Ÿåˆ—ç›‘æ§ç®¡ç†å™¨
class QueueMonitoringManager {
  constructor(token) {
    this.token = token;
    this.monitoringTasks = new Map();
    this.alertThresholds = {
      maxMessages: 5000,
      maxAge: 24 * 60 * 60 * 1000, // 24å°æ—¶
      minConsumeRate: 0.1
    };
  }
  
  async getQueueMetrics(queueId) {
    const detail = await getQueueDetail(this.token, queueId);
    const queueData = detail.data;
    
    return {
      queueId: queueId,
      queueName: queueData.queueName,
      messageCount: queueData.msgNum,
      messageSize: queueData.msgSize,
      consumeRate: parseFloat(queueData.consumeRate),
      status: queueData.status,
      createTime: new Date(queueData.createTime),
      updateTime: queueData.updateTime ? new Date(queueData.updateTime) : null,
      connectUrl: queueData.connectUrl,
      description: queueData.queueDesc
    };
  }
  
  async startMonitoring(queueId, intervalMinutes = 5) {
    const intervalMs = intervalMinutes * 60 * 1000;
    
    const task = setInterval(async () => {
      try {
        const metrics = await this.getQueueMetrics(queueId);
        
        // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
        const alerts = this.checkAlerts(metrics);
        
        if (alerts.length > 0) {
          console.log(`âš ï¸  é˜Ÿåˆ— ${metrics.queueName} è§¦å‘å‘Šè­¦:`);
          alerts.forEach(alert => console.log(`  - ${alert}`));
        }
        
        // è®°å½•ç›‘æ§æ•°æ®
        console.log(`ğŸ“Š é˜Ÿåˆ— ${metrics.queueName} ç›‘æ§æ•°æ®:`);
        console.log(`  æ¶ˆæ¯æ•°: ${metrics.messageCount}`);
        console.log(`  æ¶ˆè´¹é€Ÿç‡: ${metrics.consumeRate}/s`);
        console.log(`  çŠ¶æ€: ${metrics.status}`);
        
      } catch (error) {
        console.error(`ç›‘æ§é˜Ÿåˆ— ${queueId} æ—¶å‘ç”Ÿé”™è¯¯:`, error.message);
      }
    }, intervalMs);
    
    this.monitoringTasks.set(queueId, task);
    console.log(`å¼€å§‹ç›‘æ§é˜Ÿåˆ— ${queueId}ï¼Œé—´éš” ${intervalMinutes} åˆ†é’Ÿ`);
    
    return task;
  }
  
  stopMonitoring(queueId) {
    const task = this.monitoringTasks.get(queueId);
    if (task) {
      clearInterval(task);
      this.monitoringTasks.delete(queueId);
      console.log(`åœæ­¢ç›‘æ§é˜Ÿåˆ— ${queueId}`);
      return true;
    }
    return false;
  }
  
  checkAlerts(metrics) {
    const alerts = [];
    
    // æ¶ˆæ¯ç§¯å‹å‘Šè­¦
    if (metrics.messageCount > this.alertThresholds.maxMessages) {
      alerts.push(`æ¶ˆæ¯ç§¯å‹è¶…è¿‡é˜ˆå€¼: ${metrics.messageCount} > ${this.alertThresholds.maxMessages}`);
    }
    
    // æ¶ˆè´¹é€Ÿç‡å‘Šè­¦
    if (metrics.consumeRate < this.alertThresholds.minConsumeRate && metrics.messageCount > 0) {
      alerts.push(`æ¶ˆè´¹é€Ÿç‡è¿‡ä½: ${metrics.consumeRate} < ${this.alertThresholds.minConsumeRate}`);
    }
    
    // çŠ¶æ€å¼‚å¸¸å‘Šè­¦
    if (metrics.status !== 0) {
      alerts.push(`é˜Ÿåˆ—çŠ¶æ€å¼‚å¸¸: ${metrics.status}`);
    }
    
    return alerts;
  }
  
  async generateReport(queueIds) {
    const report = {
      timestamp: new Date().toISOString(),
      totalQueues: queueIds.length,
      healthyQueues: 0,
      unhealthyQueues: 0,
      totalMessages: 0,
      queues: []
    };
    
    for (const queueId of queueIds) {
      try {
        const metrics = await this.getQueueMetrics(queueId);
        const alerts = this.checkAlerts(metrics);
        
        const queueReport = {
          ...metrics,
          isHealthy: alerts.length === 0,
          alerts: alerts
        };
        
        report.queues.push(queueReport);
        
        if (queueReport.isHealthy) {
          report.healthyQueues++;
        } else {
          report.unhealthyQueues++;
        }
        
        report.totalMessages += metrics.messageCount;
        
      } catch (error) {
        report.queues.push({
          queueId: queueId,
          error: error.message,
          isHealthy: false
        });
        report.unhealthyQueues++;
      }
    }
    
    return report;
  }
  
  stopAllMonitoring() {
    this.monitoringTasks.forEach(task => clearInterval(task));
    this.monitoringTasks.clear();
    console.log('æ‰€æœ‰ç›‘æ§ä»»åŠ¡å·²åœæ­¢');
  }
}

// ä½¿ç”¨ç›‘æ§ç®¡ç†å™¨
const monitor = new QueueMonitoringManager(token);

// å•ä¸ªé˜Ÿåˆ—ç›‘æ§
const metrics = await monitor.getQueueMetrics(12345);
console.log('é˜Ÿåˆ—æŒ‡æ ‡:', metrics);

// å¼€å§‹ç›‘æ§
monitor.startMonitoring(12345, 1); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

// ç”ŸæˆæŠ¥å‘Š
const queueIds = [12345, 54321, 67890];
const report = await monitor.generateReport(queueIds);
console.log('é˜Ÿåˆ—å¥åº·æŠ¥å‘Š:', report);

// é˜Ÿåˆ—è¿æ¥ä¿¡æ¯è§£æå™¨
function parseConnectUrl(connectUrl) {
  if (!connectUrl) return null;
  
  try {
    const url = new URL(connectUrl);
    return {
      protocol: url.protocol.slice(0, -1), // å»æ‰å†’å·
      hostname: url.hostname,
      port: url.port || (url.protocol === 'amqps:' ? 5671 : 5672),
      virtualHost: url.pathname.slice(1), // å»æ‰å¼€å¤´çš„æ–œæ 
      isSecure: url.protocol === 'amqps:'
    };
  } catch (error) {
    console.error('è§£æè¿æ¥åœ°å€å¤±è´¥:', error.message);
    return null;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const detail = await getQueueDetail(token, 12345);
const connectionInfo = parseConnectUrl(detail.data.connectUrl);
console.log('è¿æ¥ä¿¡æ¯:', connectionInfo);
```

```python Python
import requests
import time
import json
from typing import Dict, List, Optional
from datetime import datetime, timedelta
from urllib.parse import urlparse

def get_queue_detail(token: str, queue_id: int) -> Dict:
    """
    è·å–é˜Ÿåˆ—è¯¦ç»†ä¿¡æ¯
    
    Args:
        token: JWTè®¤è¯token
        queue_id: é˜Ÿåˆ—ID
        
    Returns:
        é˜Ÿåˆ—è¯¦æƒ…æ•°æ®
    """
    url = f"https://iot-api.quectelcn.com/v2/quecrule/r1/openapi/queue/detail"
    
    headers = {
        "Authorization": token,
        "Content-Type": "application/x-www-form-urlencoded"
    }
    
    params = {"queueId": queue_id}
    
    response = requests.get(url, headers=headers, params=params)
    response.raise_for_status()
    
    return response.json()

# åŸºæœ¬æŸ¥è¯¢æ“ä½œ
try:
    detail = get_queue_detail(token, 12345)
    print(f"é˜Ÿåˆ—è¯¦æƒ…: {detail['data']}")
except Exception as e:
    print(f"è·å–é˜Ÿåˆ—è¯¦æƒ…å¤±è´¥: {e}")

# é˜Ÿåˆ—å¥åº·æ£€æŸ¥å™¨
def check_queue_health(token: str, queue_id: int) -> Dict:
    """æ£€æŸ¥é˜Ÿåˆ—å¥åº·çŠ¶æ€"""
    
    try:
        detail = get_queue_detail(token, queue_id)
        queue_data = detail['data']
        
        health_status = {
            "queue_id": queue_id,
            "queue_name": queue_data.get('queueName', ''),
            "is_healthy": True,
            "issues": [],
            "recommendations": []
        }
        
        # æ£€æŸ¥é˜Ÿåˆ—çŠ¶æ€
        if queue_data.get('status', 0) != 0:
            health_status["is_healthy"] = False
            health_status["issues"].append(f"é˜Ÿåˆ—çŠ¶æ€å¼‚å¸¸: {queue_data['status']}")
        
        # æ£€æŸ¥æ¶ˆæ¯ç§¯å‹
        msg_num = queue_data.get('msgNum', 0)
        if msg_num > 10000:
            health_status["is_healthy"] = False
            health_status["issues"].append(f"æ¶ˆæ¯ç§¯å‹è¿‡å¤š: {msg_num}")
            health_status["recommendations"].append("è€ƒè™‘å¢åŠ æ¶ˆè´¹è€…æ•°é‡æˆ–ä¼˜åŒ–æ¶ˆæ¯å¤„ç†é€»è¾‘")
        
        # æ£€æŸ¥æ¶ˆè´¹é€Ÿç‡
        consume_rate = float(queue_data.get('consumeRate', '0'))
        if consume_rate == 0 and msg_num > 0:
            health_status["is_healthy"] = False
            health_status["issues"].append("æ¶ˆè´¹é€Ÿç‡ä¸º0ä½†å­˜åœ¨æ¶ˆæ¯ç§¯å‹")
            health_status["recommendations"].append("æ£€æŸ¥æ¶ˆè´¹è€…è¿æ¥çŠ¶æ€")
        
        # æ£€æŸ¥è¿æ¥åœ°å€
        if not queue_data.get('connectUrl'):
            health_status["issues"].append("ç¼ºå°‘è¿æ¥åœ°å€é…ç½®")
        
        return health_status
        
    except Exception as e:
        return {
            "queue_id": queue_id,
            "is_healthy": False,
            "issues": [f"è·å–é˜Ÿåˆ—è¯¦æƒ…å¤±è´¥: {e}"],
            "recommendations": ["æ£€æŸ¥ç½‘ç»œè¿æ¥å’Œè®¤è¯ä¿¡æ¯"]
        }

# æ‰¹é‡æ£€æŸ¥å¤šä¸ªé˜Ÿåˆ—
def check_multiple_queues(token: str, queue_ids: List[int]) -> List[Dict]:
    """æ‰¹é‡æ£€æŸ¥é˜Ÿåˆ—å¥åº·çŠ¶æ€"""
    
    results = []
    
    for queue_id in queue_ids:
        health = check_queue_health(token, queue_id)
        results.append(health)
        
        # è¾“å‡ºå¥åº·çŠ¶æ€
        if health["is_healthy"]:
            print(f"âœ“ é˜Ÿåˆ— {queue_id} ({health['queue_name']}) çŠ¶æ€æ­£å¸¸")
        else:
            print(f"âœ— é˜Ÿåˆ— {queue_id} ({health['queue_name']}) å­˜åœ¨é—®é¢˜:")
            for issue in health["issues"]:
                print(f"  - {issue}")
            if health["recommendations"]:
                print("  å»ºè®®:")
                for rec in health["recommendations"]:
                    print(f"  - {rec}")
    
    return results

# é˜Ÿåˆ—ç›‘æ§ç®¡ç†å™¨
class QueueMonitoringManager:
    def __init__(self, token: str):
        self.token = token
        self.alert_thresholds = {
            "max_messages": 5000,
            "max_age_hours": 24,
            "min_consume_rate": 0.1
        }
        self.monitoring_active = False
    
    def get_queue_metrics(self, queue_id: int) -> Dict:
        """è·å–é˜Ÿåˆ—æŒ‡æ ‡"""
        
        detail = get_queue_detail(self.token, queue_id)
        queue_data = detail['data']
        
        metrics = {
            "queue_id": queue_id,
            "queue_name": queue_data.get('queueName', ''),
            "message_count": queue_data.get('msgNum', 0),
            "message_size": queue_data.get('msgSize', '0'),
            "consume_rate": float(queue_data.get('consumeRate', '0')),
            "status": queue_data.get('status', 0),
            "connect_url": queue_data.get('connectUrl', ''),
            "description": queue_data.get('queueDesc', ''),
            "create_time": queue_data.get('createTime'),
            "update_time": queue_data.get('updateTime')
        }
        
        return metrics
    
    def check_alerts(self, metrics: Dict) -> List[str]:
        """æ£€æŸ¥å‘Šè­¦æ¡ä»¶"""
        
        alerts = []
        
        # æ¶ˆæ¯ç§¯å‹å‘Šè­¦
        if metrics["message_count"] > self.alert_thresholds["max_messages"]:
            alerts.append(f"æ¶ˆæ¯ç§¯å‹è¶…è¿‡é˜ˆå€¼: {metrics['message_count']} > {self.alert_thresholds['max_messages']}")
        
        # æ¶ˆè´¹é€Ÿç‡å‘Šè­¦
        if metrics["consume_rate"] < self.alert_thresholds["min_consume_rate"] and metrics["message_count"] > 0:
            alerts.append(f"æ¶ˆè´¹é€Ÿç‡è¿‡ä½: {metrics['consume_rate']} < {self.alert_thresholds['min_consume_rate']}")
        
        # çŠ¶æ€å¼‚å¸¸å‘Šè­¦
        if metrics["status"] != 0:
            alerts.append(f"é˜Ÿåˆ—çŠ¶æ€å¼‚å¸¸: {metrics['status']}")
        
        return alerts
    
    def generate_report(self, queue_ids: List[int]) -> Dict:
        """ç”Ÿæˆé˜Ÿåˆ—å¥åº·æŠ¥å‘Š"""
        
        report = {
            "timestamp": datetime.now().isoformat(),
            "total_queues": len(queue_ids),
            "healthy_queues": 0,
            "unhealthy_queues": 0,
            "total_messages": 0,
            "queues": []
        }
        
        for queue_id in queue_ids:
            try:
                metrics = self.get_queue_metrics(queue_id)
                alerts = self.check_alerts(metrics)
                
                queue_report = {
                    **metrics,
                    "is_healthy": len(alerts) == 0,
                    "alerts": alerts
                }
                
                report["queues"].append(queue_report)
                
                if queue_report["is_healthy"]:
                    report["healthy_queues"] += 1
                else:
                    report["unhealthy_queues"] += 1
                
                report["total_messages"] += metrics["message_count"]
                
            except Exception as e:
                report["queues"].append({
                    "queue_id": queue_id,
                    "error": str(e),
                    "is_healthy": False
                })
                report["unhealthy_queues"] += 1
        
        return report
    
    def export_report(self, report: Dict, filename: str = None) -> str:
        """å¯¼å‡ºæŠ¥å‘Šåˆ°æ–‡ä»¶"""
        
        if not filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"queue_health_report_{timestamp}.json"
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, ensure_ascii=False, indent=2)
        
        return filename
    
    def start_continuous_monitoring(self, queue_ids: List[int], interval_minutes: int = 5):
        """å¼€å§‹æŒç»­ç›‘æ§"""
        
        self.monitoring_active = True
        
        while self.monitoring_active:
            try:
                print(f"å¼€å§‹ç›‘æ§æ£€æŸ¥ - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                
                for queue_id in queue_ids:
                    try:
                        metrics = self.get_queue_metrics(queue_id)
                        alerts = self.check_alerts(metrics)
                        
                        if alerts:
                            print(f"âš ï¸  é˜Ÿåˆ— {metrics['queue_name']} è§¦å‘å‘Šè­¦:")
                            for alert in alerts:
                                print(f"  - {alert}")
                        
                        print(f"ğŸ“Š é˜Ÿåˆ— {metrics['queue_name']} ç›‘æ§æ•°æ®:")
                        print(f"  æ¶ˆæ¯æ•°: {metrics['message_count']}")
                        print(f"  æ¶ˆè´¹é€Ÿç‡: {metrics['consume_rate']}/s")
                        print(f"  çŠ¶æ€: {metrics['status']}")
                        
                    except Exception as e:
                        print(f"ç›‘æ§é˜Ÿåˆ— {queue_id} æ—¶å‘ç”Ÿé”™è¯¯: {e}")
                
                # ç­‰å¾…ä¸‹ä¸€æ¬¡æ£€æŸ¥
                time.sleep(interval_minutes * 60)
                
            except KeyboardInterrupt:
                print("ç›‘æ§è¢«ç”¨æˆ·ä¸­æ–­")
                break
            except Exception as e:
                print(f"ç›‘æ§è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
                time.sleep(30)  # é”™è¯¯åç­‰å¾…30ç§’å†ç»§ç»­
    
    def stop_monitoring(self):
        """åœæ­¢ç›‘æ§"""
        self.monitoring_active = False
        print("ç›‘æ§å·²åœæ­¢")

# è¿æ¥ä¿¡æ¯è§£æå™¨
def parse_connect_url(connect_url: str) -> Optional[Dict]:
    """è§£æAMQPè¿æ¥åœ°å€"""
    
    if not connect_url:
        return None
    
    try:
        parsed = urlparse(connect_url)
        
        return {
            "protocol": parsed.scheme,
            "hostname": parsed.hostname,
            "port": parsed.port or (5671 if parsed.scheme == 'amqps' else 5672),
            "virtual_host": parsed.path.lstrip('/'),
            "is_secure": parsed.scheme == 'amqps'
        }
    except Exception as e:
        print(f"è§£æè¿æ¥åœ°å€å¤±è´¥: {e}")
        return None

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆ›å»ºç›‘æ§ç®¡ç†å™¨
    monitor = QueueMonitoringManager(token)
    
    # å•ä¸ªé˜Ÿåˆ—ç›‘æ§
    try:
        metrics = monitor.get_queue_metrics(12345)
        print(f"é˜Ÿåˆ—æŒ‡æ ‡: {metrics}")
        
        # è§£æè¿æ¥ä¿¡æ¯
        connection_info = parse_connect_url(metrics["connect_url"])
        print(f"è¿æ¥ä¿¡æ¯: {connection_info}")
        
    except Exception as e:
        print(f"è·å–é˜Ÿåˆ—æŒ‡æ ‡å¤±è´¥: {e}")
    
    # ç”Ÿæˆå¥åº·æŠ¥å‘Š
    queue_ids = [12345, 54321, 67890]
    report = monitor.generate_report(queue_ids)
    
    print(f"\né˜Ÿåˆ—å¥åº·æŠ¥å‘Š:")
    print(f"æ€»é˜Ÿåˆ—æ•°: {report['total_queues']}")
    print(f"å¥åº·é˜Ÿåˆ—: {report['healthy_queues']}")
    print(f"å¼‚å¸¸é˜Ÿåˆ—: {report['unhealthy_queues']}")
    print(f"æ€»æ¶ˆæ¯æ•°: {report['total_messages']}")
    
    # å¯¼å‡ºæŠ¥å‘Š
    report_file = monitor.export_report(report)
    print(f"æŠ¥å‘Šå·²å¯¼å‡ºåˆ°: {report_file}")
```

```curl cURL
# æŸ¥è¯¢é˜Ÿåˆ—è¯¦æƒ…
curl -X GET "https://iot-api.quectelcn.com/v2/quecrule/r1/openapi/queue/detail?queueId=12345" \
  -H "Authorization: YOUR_JWT_TOKEN" \
  -H "Content-Type: application/x-www-form-urlencoded"

# æŸ¥è¯¢å¤šä¸ªé˜Ÿåˆ—è¯¦æƒ…
QUEUE_IDS=(12345 54321 67890)
TOKEN="YOUR_JWT_TOKEN"

for queue_id in "${QUEUE_IDS[@]}"; do
  echo "æŸ¥è¯¢é˜Ÿåˆ— $queue_id è¯¦æƒ…:"
  
  curl -X GET "https://iot-api.quectelcn.com/v2/quecrule/r1/openapi/queue/detail?queueId=${queue_id}" \
    -H "Authorization: ${TOKEN}" \
    -H "Content-Type: application/x-www-form-urlencoded"
  
  echo -e "\n"
done

# é˜Ÿåˆ—å¥åº·æ£€æŸ¥è„šæœ¬
#!/bin/bash
TOKEN="YOUR_JWT_TOKEN"
QUEUE_ID=12345

# è·å–é˜Ÿåˆ—è¯¦æƒ…
response=$(curl -s -X GET "https://iot-api.quectelcn.com/v2/quecrule/r1/openapi/queue/detail?queueId=${QUEUE_ID}" \
  -H "Authorization: ${TOKEN}" \
  -H "Content-Type: application/x-www-form-urlencoded")

# è§£æå“åº”
echo "é˜Ÿåˆ—è¯¦æƒ…å“åº”:"
echo "$response" | jq .

# æå–å…³é”®æŒ‡æ ‡
queue_name=$(echo "$response" | jq -r '.data.queueName')
msg_num=$(echo "$response" | jq -r '.data.msgNum')
consume_rate=$(echo "$response" | jq -r '.data.consumeRate')
status=$(echo "$response" | jq -r '.data.status')

echo "é˜Ÿåˆ—å¥åº·æ£€æŸ¥:"
echo "é˜Ÿåˆ—åç§°: $queue_name"
echo "æ¶ˆæ¯æ•°é‡: $msg_num"
echo "æ¶ˆè´¹é€Ÿç‡: $consume_rate"
echo "é˜Ÿåˆ—çŠ¶æ€: $status"

# ç®€å•çš„å¥åº·æ£€æŸ¥
if [ "$status" -eq 0 ]; then
  echo "âœ“ é˜Ÿåˆ—çŠ¶æ€æ­£å¸¸"
else
  echo "âœ— é˜Ÿåˆ—çŠ¶æ€å¼‚å¸¸"
fi

if [ "$msg_num" -gt 5000 ]; then
  echo "âš ï¸  æ¶ˆæ¯ç§¯å‹è¿‡å¤š: $msg_num"
fi

# ç›‘æ§è„šæœ¬
#!/bin/bash
TOKEN="YOUR_JWT_TOKEN"
QUEUE_IDS=(12345 54321 67890)
INTERVAL=60  # ç›‘æ§é—´éš”ï¼ˆç§’ï¼‰

while true; do
  echo "å¼€å§‹ç›‘æ§æ£€æŸ¥ - $(date)"
  
  for queue_id in "${QUEUE_IDS[@]}"; do
    echo "æ£€æŸ¥é˜Ÿåˆ—: $queue_id"
    
    response=$(curl -s -X GET "https://iot-api.quectelcn.com/v2/quecrule/r1/openapi/queue/detail?queueId=${queue_id}" \
      -H "Authorization: ${TOKEN}" \
      -H "Content-Type: application/x-www-form-urlencoded")
    
    # æ£€æŸ¥å“åº”æ˜¯å¦æˆåŠŸ
    if [ $? -eq 0 ]; then
      msg_num=$(echo "$response" | jq -r '.data.msgNum')
      consume_rate=$(echo "$response" | jq -r '.data.consumeRate')
      
      echo "  æ¶ˆæ¯æ•°: $msg_num, æ¶ˆè´¹é€Ÿç‡: $consume_rate"
      
      # å‘Šè­¦æ£€æŸ¥
      if [ "$msg_num" -gt 5000 ]; then
        echo "  âš ï¸  æ¶ˆæ¯ç§¯å‹å‘Šè­¦: $msg_num"
      fi
    else
      echo "  âœ— è·å–é˜Ÿåˆ—è¯¦æƒ…å¤±è´¥"
    fi
    
    echo ""
  done
  
  sleep $INTERVAL
done
```

</CodeGroup>

## å“åº”ç¤ºä¾‹

### æˆåŠŸå“åº”

```json
{
  "code": 200,
  "msg": "OK",
  "data": {
    "queueId": 6611,
    "queueName": "a.1358403955870720.testQueue",
    "queueDesc": "æµ‹è¯•é˜Ÿåˆ—æè¿°",
    "createTime": 1730871805000,
    "updateTime": null,
    "status": 0,
    "msgNum": 0,
    "msgSize": "0KB",
    "consumeRate": "0",
    "connectUrl": "amqp://127.0.0.1:5672/quec-open"
  }
}
```

### é”™è¯¯å“åº”

```json
{
  "code": 16002,
  "msg": "The queue name does not exist"
}
```

## å­—æ®µè¯´æ˜

<AccordionGroup>
  <Accordion title="åŸºæœ¬ä¿¡æ¯å­—æ®µ">
    - **queueId**: é˜Ÿåˆ—å”¯ä¸€æ ‡è¯†ç¬¦
    - **queueName**: é˜Ÿåˆ—åç§°
    - **queueDesc**: é˜Ÿåˆ—æè¿°ä¿¡æ¯
    - **createTime**: é˜Ÿåˆ—åˆ›å»ºæ—¶é—´æˆ³
    - **updateTime**: æœ€åæ›´æ–°æ—¶é—´æˆ³
  </Accordion>
  
  <Accordion title="è¿è¡ŒçŠ¶æ€å­—æ®µ">
    - **status**: é˜Ÿåˆ—çŠ¶æ€ï¼ˆ0: æ­£å¸¸, 1: å¼‚å¸¸ï¼‰
    - **msgNum**: é˜Ÿåˆ—ä¸­æœªæ¶ˆè´¹æ¶ˆæ¯æ•°é‡
    - **msgSize**: æ¶ˆæ¯æ€»å¤§å°ï¼ˆåŒ…å«å•ä½ï¼‰
    - **consumeRate**: æ¶ˆæ¯æ¶ˆè´¹é€Ÿç‡ï¼ˆæ¶ˆæ¯/ç§’ï¼‰
  </Accordion>
  
  <Accordion title="è¿æ¥é…ç½®å­—æ®µ">
    - **connectUrl**: AMQPè¿æ¥åœ°å€
    - æ ¼å¼: `amqp://hostname:port/virtualHost`
    - æ”¯æŒSSLè¿æ¥: `amqps://hostname:port/virtualHost`
  </Accordion>
</AccordionGroup>

## çŠ¶æ€ç è¯´æ˜

| çŠ¶æ€ç  | å«ä¹‰ | è¯´æ˜ |
|--------|------|------|
| 0 | æ­£å¸¸ | é˜Ÿåˆ—è¿è¡Œæ­£å¸¸ï¼Œå¯ä»¥æ¥æ”¶å’Œå‘é€æ¶ˆæ¯ |
| 1 | å¼‚å¸¸ | é˜Ÿåˆ—å­˜åœ¨é—®é¢˜ï¼Œéœ€è¦æ£€æŸ¥é…ç½®æˆ–è¿æ¥ |
| 2 | æš‚åœ | é˜Ÿåˆ—æš‚æ—¶åœæ­¢æœåŠ¡ |
| 3 | ç»´æŠ¤ | é˜Ÿåˆ—æ­£åœ¨ç»´æŠ¤ä¸­ |

## æ¶ˆæ¯å¤§å°å•ä½

| å•ä½ | å«ä¹‰ | å­—èŠ‚æ•° |
|------|------|--------|
| B | å­—èŠ‚ | 1 |
| KB | åƒå­—èŠ‚ | 1,024 |
| MB | å…†å­—èŠ‚ | 1,048,576 |
| GB | å‰å­—èŠ‚ | 1,073,741,824 |

## ç›‘æ§æŒ‡æ ‡

<CardGroup cols={2}>
  <Card title="æ¶ˆæ¯ç§¯å‹" icon="inbox">
    ç›‘æ§msgNumå­—æ®µï¼Œè®¾ç½®å‘Šè­¦é˜ˆå€¼
  </Card>
  <Card title="æ¶ˆè´¹é€Ÿç‡" icon="tachometer-alt">
    ç›‘æ§consumeRateå­—æ®µï¼Œè¯„ä¼°å¤„ç†æ€§èƒ½
  </Card>
  <Card title="æ¶ˆæ¯å¤§å°" icon="weight">
    ç›‘æ§msgSizeå­—æ®µï¼Œè¿›è¡Œå®¹é‡è§„åˆ’
  </Card>
  <Card title="çŠ¶æ€å¥åº·" icon="heartbeat">
    ç›‘æ§statuså­—æ®µï¼ŒåŠæ—¶å‘ç°å¼‚å¸¸
  </Card>
</CardGroup>

## æœ€ä½³å®è·µ

<Steps>
  <Step title="å®šæœŸæ£€æŸ¥">
    å»ºç«‹å®šæœŸæ£€æŸ¥æœºåˆ¶ï¼Œç›‘æ§é˜Ÿåˆ—å¥åº·çŠ¶æ€
  </Step>
  <Step title="å‘Šè­¦è®¾ç½®">
    ä¸ºå…³é”®æŒ‡æ ‡è®¾ç½®åˆç†çš„å‘Šè­¦é˜ˆå€¼
  </Step>
  <Step title="æ€§èƒ½åˆ†æ">
    åˆ†ææ¶ˆè´¹é€Ÿç‡å’Œæ¶ˆæ¯ç§¯å‹è¶‹åŠ¿
  </Step>
  <Step title="å®¹é‡è§„åˆ’">
    æ ¹æ®æ¶ˆæ¯å¤§å°å’Œå¢é•¿é€Ÿåº¦è§„åˆ’å­˜å‚¨
  </Step>
</Steps>

## ä½¿ç”¨åœºæ™¯

<CardGroup cols={2}>
  <Card title="è¿ç»´ç›‘æ§" icon="chart-line">
    å®æ—¶ç›‘æ§é˜Ÿåˆ—çŠ¶æ€å’Œæ€§èƒ½æŒ‡æ ‡
  </Card>
  <Card title="æ•…éšœè¯Šæ–­" icon="stethoscope">
    åˆ†æé˜Ÿåˆ—é—®é¢˜çš„æ ¹æœ¬åŸå› 
  </Card>
  <Card title="æ€§èƒ½ä¼˜åŒ–" icon="rocket">
    ä¼˜åŒ–æ¶ˆè´¹è€…é…ç½®å’Œå¤„ç†é€»è¾‘
  </Card>
  <Card title="å®¹é‡ç®¡ç†" icon="server">
    è§„åˆ’é˜Ÿåˆ—å®¹é‡å’Œæ‰©å±•ç­–ç•¥
  </Card>
</CardGroup>

## é”™è¯¯å¤„ç†

| é”™è¯¯ç  | æè¿° | è§£å†³æ–¹æ¡ˆ |
|--------|------|----------|
| 16002 | é˜Ÿåˆ—ä¸å­˜åœ¨ | æ£€æŸ¥é˜Ÿåˆ—IDæ˜¯å¦æ­£ç¡® |
| 50000 | æœåŠ¡å¼‚å¸¸ | ç¨åé‡è¯•æˆ–è”ç³»æŠ€æœ¯æ”¯æŒ |
| 50005 | å‚æ•°é”™è¯¯ | æ£€æŸ¥è¯·æ±‚å‚æ•°æ ¼å¼ |
| 91004 | Tokenæ— æ•ˆ | æ£€æŸ¥è®¤è¯tokenæ˜¯å¦æœ‰æ•ˆ |
| 91005 | æƒé™ä¸è¶³ | æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰é˜Ÿåˆ—æŸ¥çœ‹æƒé™ |

## ç›¸å…³æ¥å£

<CardGroup cols={2}>
  <Card title="é˜Ÿåˆ—åˆ—è¡¨" href="/api-reference/endpoint/queue-list">
    æŸ¥çœ‹æ‰€æœ‰é˜Ÿåˆ—çš„æ¦‚è§ˆä¿¡æ¯
  </Card>
  <Card title="é˜Ÿåˆ—åˆ›å»º" href="/api-reference/endpoint/queue-create">
    åˆ›å»ºæ–°çš„æ¶ˆæ¯é˜Ÿåˆ—
  </Card>
  <Card title="é˜Ÿåˆ—æ¸…ç†" href="/api-reference/endpoint/queue-clear">
    æ¸…ç†é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯
  </Card>
  <Card title="è®¢é˜…ç®¡ç†" href="/api-reference/endpoint/subscription-list">
    ç®¡ç†é˜Ÿåˆ—çš„æ¶ˆæ¯è®¢é˜…
  </Card>
</CardGroup>